"""
Container security scanning and vulnerability assessment for campus security system.
"""
import asyncio
import json
import subprocess
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
import structlog
import aiofiles
import aiohttp

logger = structlog.get_logger()


class SeverityLevel(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """Vulnerability status."""
    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    FIXED = "fixed"
    FALSE_POSITIVE = "false_positive"


@dataclass
class Vulnerability:
    """Vulnerability information."""
    id: str
    title: str
    description: str
    severity: SeverityLevel
    cvss_score: Optional[float]
    cve_id: Optional[str]
    package_name: str
    package_version: str
    fixed_version: Optional[str]
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN
    discovered_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.discovered_at is None:
            self.discovered_at = datetime.utcnow()
        if self.updated_at is None:
            self.updated_at = datetime.utcnow()


@dataclass
class ScanResult:
    """Container scan result."""
    image_name: str
    image_tag: str
    scan_id: str
    scan_date: datetime
    vulnerabilities: List[Vulnerability]
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    scan_duration: float
    
    def get_risk_score(self) -> float:
        """Calculate risk score based on vulnerabilities."""
        score = 0.0
        score += self.critical_count * 10.0
        score += self.high_count * 7.0
        score += self.medium_count * 4.0
        score += self.low_count * 1.0
        return score


class VulnerabilityScanner:
    """Container vulnerability scanner using multiple tools."""
    
    def __init__(self):
        self.scan_results: Dict[str, ScanResult] = {}
        self.vulnerability_db: Dict[str, Vulnerability] = {}
        self.scan_policies: Dict[str, Any] = {}
        self.initialize_policies()
    
    def initialize_policies(self):
        """Initialize default scanning policies."""
        self.scan_policies = {
            "max_critical_vulnerabilities": 0,
            "max_high_vulnerabilities": 5,
            "max_medium_vulnerabilities": 20,
            "scan_frequency_hours": 24,
            "auto_fix_enabled": True,
            "notification_threshold": SeverityLevel.HIGH,
            "excluded_packages": [],
            "excluded_cves": []
        }
        logger.info("Vulnerability scanning policies initialized")
    
    async def scan_container_image(self, image_name: str, image_tag: str = "latest") -> ScanResult:
        """Scan container image for vulnerabilities."""
        scan_id = f"{image_name}:{image_tag}_{datetime.utcnow().isoformat()}"
        start_time = datetime.utcnow()
        
        logger.info("Starting container vulnerability scan", 
                   image=f"{image_name}:{image_tag}", scan_id=scan_id)
        
        try:
            # Run Trivy scan
            trivy_results = await self._run_trivy_scan(image_name, image_tag)
            
            # Run Grype scan (if available)
            grype_results = await self._run_grype_scan(image_name, image_tag)
            
            # Merge and deduplicate results
            vulnerabilities = self._merge_scan_results(trivy_results, grype_results)
            
            # Calculate statistics
            severity_counts = self._calculate_severity_counts(vulnerabilities)
            
            scan_duration = (datetime.utcnow() - start_time).total_seconds()
            
            scan_result = ScanResult(
                image_name=image_name,
                image_tag=image_tag,
                scan_id=scan_id,
                scan_date=start_time,
                vulnerabilities=vulnerabilities,
                total_vulnerabilities=len(vulnerabilities),
                critical_count=severity_counts.get(SeverityLevel.CRITICAL, 0),
                high_count=severity_counts.get(SeverityLevel.HIGH, 0),
                medium_count=severity_counts.get(SeverityLevel.MEDIUM, 0),
                low_count=severity_counts.get(SeverityLevel.LOW, 0),
                scan_duration=scan_duration
            )
            
            # Store scan result
            self.scan_results[f"{image_name}:{image_tag}"] = scan_result
            
            # Update vulnerability database
            for vuln in vulnerabilities:
                self.vulnerability_db[vuln.id] = vuln
            
            # Check against policies
            policy_violations = self._check_policy_violations(scan_result)
            if policy_violations:
                logger.warning("Policy violations detected", 
                             image=f"{image_name}:{image_tag}",
                             violations=policy_violations)
            
            logger.info("Container vulnerability scan completed",
                       image=f"{image_name}:{image_tag}",
                       total_vulnerabilities=scan_result.total_vulnerabilities,
                       critical=scan_result.critical_count,
                       high=scan_result.high_count,
                       duration=scan_duration)
            
            return scan_result
            
        except Exception as e:
            logger.error("Container vulnerability scan failed",
                        image=f"{image_name}:{image_tag}",
                        error=str(e))
            raise
    
    async def _run_trivy_scan(self, image_name: str, image_tag: str) -> List[Dict]:
        """Run Trivy vulnerability scan."""
        try:
            cmd = [
                "trivy", "image",
                "--format", "json",
                "--severity", "CRITICAL,HIGH,MEDIUM,LOW",
                f"{image_name}:{image_tag}"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.warning("Trivy scan completed with warnings",
                             stderr=stderr.decode())
            
            if stdout:
                trivy_output = json.loads(stdout.decode())
                return self._parse_trivy_output(trivy_output)
            
            return []
            
        except FileNotFoundError:
            logger.warning("Trivy not found, skipping Trivy scan")
            return []
        except Exception as e:
            logger.error("Trivy scan failed", error=str(e))
            return []
    
    async def _run_grype_scan(self, image_name: str, image_tag: str) -> List[Dict]:
        """Run Grype vulnerability scan."""
        try:
            cmd = [
                "grype",
                "-o", "json",
                f"{image_name}:{image_tag}"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.warning("Grype scan completed with warnings",
                             stderr=stderr.decode())
            
            if stdout:
                grype_output = json.loads(stdout.decode())
                return self._parse_grype_output(grype_output)
            
            return []
            
        except FileNotFoundError:
            logger.warning("Grype not found, skipping Grype scan")
            return []
        except Exception as e:
            logger.error("Grype scan failed", error=str(e))
            return []
    
    def _parse_trivy_output(self, trivy_output: Dict) -> List[Vulnerability]:
        """Parse Trivy scan output."""
        vulnerabilities = []
        
        for result in trivy_output.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                vulnerability = Vulnerability(
                    id=f"trivy_{vuln.get('VulnerabilityID', 'unknown')}",
                    title=vuln.get("Title", "Unknown vulnerability"),
                    description=vuln.get("Description", ""),
                    severity=self._map_severity(vuln.get("Severity", "UNKNOWN")),
                    cvss_score=self._extract_cvss_score(vuln),
                    cve_id=vuln.get("VulnerabilityID"),
                    package_name=vuln.get("PkgName", "unknown"),
                    package_version=vuln.get("InstalledVersion", "unknown"),
                    fixed_version=vuln.get("FixedVersion")
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _parse_grype_output(self, grype_output: Dict) -> List[Vulnerability]:
        """Parse Grype scan output."""
        vulnerabilities = []
        
        for match in grype_output.get("matches", []):
            vuln_data = match.get("vulnerability", {})
            artifact = match.get("artifact", {})
            
            vulnerability = Vulnerability(
                id=f"grype_{vuln_data.get('id', 'unknown')}",
                title=vuln_data.get("description", "Unknown vulnerability"),
                description=vuln_data.get("description", ""),
                severity=self._map_severity(vuln_data.get("severity", "Unknown")),
                cvss_score=self._extract_cvss_from_grype(vuln_data),
                cve_id=vuln_data.get("id"),
                package_name=artifact.get("name", "unknown"),
                package_version=artifact.get("version", "unknown"),
                fixed_version=vuln_data.get("fix", {}).get("versions", [None])[0]
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _merge_scan_results(self, trivy_results: List[Vulnerability], 
                          grype_results: List[Vulnerability]) -> List[Vulnerability]:
        """Merge and deduplicate scan results from multiple tools."""
        merged = {}
        
        # Add Trivy results
        for vuln in trivy_results:
            key = f"{vuln.cve_id}_{vuln.package_name}_{vuln.package_version}"
            merged[key] = vuln
        
        # Add Grype results (avoid duplicates)
        for vuln in grype_results:
            key = f"{vuln.cve_id}_{vuln.package_name}_{vuln.package_version}"
            if key not in merged:
                merged[key] = vuln
        
        return list(merged.values())
    
    def _map_severity(self, severity: str) -> SeverityLevel:
        """Map severity string to SeverityLevel enum."""
        severity_map = {
            "CRITICAL": SeverityLevel.CRITICAL,
            "HIGH": SeverityLevel.HIGH,
            "MEDIUM": SeverityLevel.MEDIUM,
            "LOW": SeverityLevel.LOW,
            "INFO": SeverityLevel.INFO,
            "UNKNOWN": SeverityLevel.INFO
        }
        return severity_map.get(severity.upper(), SeverityLevel.INFO)
    
    def _extract_cvss_score(self, vuln: Dict) -> Optional[float]:
        """Extract CVSS score from vulnerability data."""
        cvss = vuln.get("CVSS", {})
        if isinstance(cvss, dict):
            for version in ["v3", "v2"]:
                if version in cvss:
                    return cvss[version].get("Score")
        return None
    
    def _extract_cvss_from_grype(self, vuln_data: Dict) -> Optional[float]:
        """Extract CVSS score from Grype vulnerability data."""
        cvss_list = vuln_data.get("cvss", [])
        if cvss_list and isinstance(cvss_list, list):
            return cvss_list[0].get("score")
        return None
    
    def _calculate_severity_counts(self, vulnerabilities: List[Vulnerability]) -> Dict[SeverityLevel, int]:
        """Calculate vulnerability counts by severity."""
        counts = {severity: 0 for severity in SeverityLevel}
        for vuln in vulnerabilities:
            counts[vuln.severity] += 1
        return counts
    
    def _check_policy_violations(self, scan_result: ScanResult) -> List[str]:
        """Check scan result against security policies."""
        violations = []
        
        if scan_result.critical_count > self.scan_policies["max_critical_vulnerabilities"]:
            violations.append(f"Critical vulnerabilities exceed limit: {scan_result.critical_count} > {self.scan_policies['max_critical_vulnerabilities']}")
        
        if scan_result.high_count > self.scan_policies["max_high_vulnerabilities"]:
            violations.append(f"High vulnerabilities exceed limit: {scan_result.high_count} > {self.scan_policies['max_high_vulnerabilities']}")
        
        if scan_result.medium_count > self.scan_policies["max_medium_vulnerabilities"]:
            violations.append(f"Medium vulnerabilities exceed limit: {scan_result.medium_count} > {self.scan_policies['max_medium_vulnerabilities']}")
        
        return violations
    
    async def generate_vulnerability_report(self, image_name: str, image_tag: str = "latest") -> Dict:
        """Generate comprehensive vulnerability report."""
        scan_key = f"{image_name}:{image_tag}"
        scan_result = self.scan_results.get(scan_key)
        
        if not scan_result:
            raise ValueError(f"No scan results found for {scan_key}")
        
        # Group vulnerabilities by severity
        vulnerabilities_by_severity = {}
        for severity in SeverityLevel:
            vulnerabilities_by_severity[severity.value] = [
                asdict(vuln) for vuln in scan_result.vulnerabilities
                if vuln.severity == severity
            ]
        
        # Generate recommendations
        recommendations = self._generate_recommendations(scan_result)
        
        report = {
            "scan_info": {
                "image": f"{image_name}:{image_tag}",
                "scan_id": scan_result.scan_id,
                "scan_date": scan_result.scan_date.isoformat(),
                "scan_duration": scan_result.scan_duration
            },
            "summary": {
                "total_vulnerabilities": scan_result.total_vulnerabilities,
                "critical": scan_result.critical_count,
                "high": scan_result.high_count,
                "medium": scan_result.medium_count,
                "low": scan_result.low_count,
                "risk_score": scan_result.get_risk_score()
            },
            "vulnerabilities_by_severity": vulnerabilities_by_severity,
            "policy_violations": self._check_policy_violations(scan_result),
            "recommendations": recommendations,
            "generated_at": datetime.utcnow().isoformat()
        }
        
        return report
    
    def _generate_recommendations(self, scan_result: ScanResult) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []
        
        if scan_result.critical_count > 0:
            recommendations.append("Immediately update packages with critical vulnerabilities")
            recommendations.append("Consider blocking deployment until critical issues are resolved")
        
        if scan_result.high_count > 5:
            recommendations.append("Schedule urgent updates for high-severity vulnerabilities")
        
        if scan_result.get_risk_score() > 50:
            recommendations.append("Overall risk score is high - prioritize security updates")
        
        # Package-specific recommendations
        package_counts = {}
        for vuln in scan_result.vulnerabilities:
            if vuln.severity in [SeverityLevel.CRITICAL, SeverityLevel.HIGH]:
                package_counts[vuln.package_name] = package_counts.get(vuln.package_name, 0) + 1
        
        for package, count in package_counts.items():
            if count > 3:
                recommendations.append(f"Consider updating or replacing {package} (multiple vulnerabilities)")
        
        return recommendations
    
    async def export_scan_results(self, output_file: str):
        """Export all scan results to file."""
        export_data = {
            "export_date": datetime.utcnow().isoformat(),
            "scan_results": {},
            "vulnerability_database": {}
        }
        
        # Export scan results
        for key, scan_result in self.scan_results.items():
            export_data["scan_results"][key] = {
                "image_name": scan_result.image_name,
                "image_tag": scan_result.image_tag,
                "scan_id": scan_result.scan_id,
                "scan_date": scan_result.scan_date.isoformat(),
                "total_vulnerabilities": scan_result.total_vulnerabilities,
                "critical_count": scan_result.critical_count,
                "high_count": scan_result.high_count,
                "medium_count": scan_result.medium_count,
                "low_count": scan_result.low_count,
                "scan_duration": scan_result.scan_duration,
                "vulnerabilities": [asdict(vuln) for vuln in scan_result.vulnerabilities]
            }
        
        # Export vulnerability database
        for vuln_id, vuln in self.vulnerability_db.items():
            export_data["vulnerability_database"][vuln_id] = asdict(vuln)
        
        async with aiofiles.open(output_file, 'w') as f:
            await f.write(json.dumps(export_data, indent=2, default=str))
        
        logger.info("Scan results exported", output_file=output_file)


# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner()